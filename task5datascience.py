# -*- coding: utf-8 -*-
"""task5datascience.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QLG3pfwtrprkA724ukUwD_sFlDMIYQ03

# **Import Libraries and data**
"""

import pandas as pd
import numpy as np
import seaborn as sb
from scipy import stats
import seaborn as sns
from matplotlib import pyplot as plt
from sklearn.linear_model import LogisticRegression
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder
from sklearn.svm import SVC
from scipy.stats.distributions import entropy
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score
from sklearn.preprocessing import StandardScaler
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import precision_recall_curve
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import confusion_matrix ,f1_score
from sklearn.metrics import classification_report
from sklearn.naive_bayes import GaussianNB
from sklearn.feature_selection import chi2
from sklearn.feature_selection import SelectKBest
from sklearn.preprocessing import LabelEncoder, OrdinalEncoder
from sklearn.ensemble import RandomForestClassifier
from sklearn.preprocessing import MinMaxScaler
from sklearn.compose import ColumnTransformer
from sklearn.compose import make_column_selector as selector
from sklearn.pipeline import Pipeline
from sklearn.feature_selection import mutual_info_classif
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import classification_report,confusion_matrix
from sklearn.metrics import accuracy_score
from sklearn import metrics
from sklearn.ensemble import AdaBoostClassifier
from sklearn.naive_bayes import GaussianNB
from sklearn.feature_selection import SelectKBest, chi2

train_data =pd.read_csv("/content/train_data (3).csv")
test_data =pd.read_csv("/content/test_data (1).csv")

"""# **Deal with missing values**"""

train_data.info()

train_data.head()

test_data.head()

test_data.info()

test_data['Income '] = test_data['Income '].replace([' <=50K.'],' <=50K')
test_data['Income '] = test_data['Income '].replace([' >50K.'],' >50K')

print(train_data.isnull().sum())

print(test_data.isnull().sum())

print(train_data.iloc[14,13])

for cols in train_data.columns:
    x = train_data[cols].isin([" ?"]).sum()
    if x > 0:
      print(cols , x)

for cols in test_data.columns:
    x = test_data[cols].isin([" ?"]).sum()
    if x > 0:
      print(cols , x)

for cols in train_data.columns:
   train_data.drop(train_data[train_data[cols] == " ?"].index,inplace=True)

train_data.info()

for cols in test_data.columns:
   test_data.drop(test_data[test_data[cols] == " ?"].index,inplace=True)

test_data.info()

train_data['marital-status'] = train_data['marital-status'].replace([' Divorced',' Married-spouse-absent',' Never-married',' Separated',' Widowed'],'Not-Married')
train_data['marital-status'] = train_data['marital-status'].replace([' Married-AF-spouse',' Married-civ-spouse'],'Married')

test_data['marital-status'] = test_data['marital-status'].replace([' Divorced',' Married-spouse-absent',' Never-married',' Separated',' Widowed'],'Not-Married')
test_data['marital-status'] = test_data['marital-status'].replace([' Married-AF-spouse',' Married-civ-spouse'],'Married')

"""# **Feature selection corr **"""

train_data_copy=train_data.copy()
test_data_copy = test_data.copy()

from sklearn.preprocessing import LabelEncoder
le=LabelEncoder()

for i in train_data_copy.columns:
  if train_data_copy[i].dtypes=='O':
    train_data_copy[i]=le.fit_transform(train_data_copy[i])

from sklearn.preprocessing import LabelEncoder
le=LabelEncoder()

for i in test_data_copy.columns:
  if test_data_copy[i].dtypes=='O':
    test_data_copy[i]=le.fit_transform(test_data_copy[i])

train_data.corr()

corr = train_data_copy.corr()

f, ax = plt.subplots(figsize=(20, 10))

sns.heatmap(corr, cmap="coolwarm", annot=True, square=False, ax=ax)
plt.title('Pearson Correlation of Features')
plt.yticks(rotation=45);

#education-num   relationship   age  hours-per-week	capital-gain

"""# **Encode the data**"""

test_data.nunique()

train_data.nunique()

print(train_data['native-country'].value_counts())

print(test_data['native-country'].value_counts())

for cols in train_data.columns:
   train_data.drop(train_data[train_data[cols] == " Holand-Netherlands"].index,inplace=True)

train_data_encoded=pd.get_dummies(train_data)

test_data_encoded=pd.get_dummies(test_data)

le=LabelEncoder()
Y_train=le.fit_transform(train_data['Income '])

le=LabelEncoder()
Y_test=le.fit_transform(test_data['Income '])

train_data_encoded.head()

test_data_encoded.head()

for i in train_data_encoded.columns:
  print(i)

X_train=train_data_encoded[['age','education-num','capital-gain','hours-per-week','relationship_ Husband','relationship_ Not-in-family','relationship_ Other-relative','relationship_ Own-child','relationship_ Unmarried','relationship_ Wife','marital-status_Married','marital-status_Not-Married']]
X_test=test_data_encoded[['age','education-num','capital-gain','hours-per-week','relationship_ Husband','relationship_ Not-in-family','relationship_ Other-relative','relationship_ Own-child','relationship_ Unmarried','relationship_ Wife','marital-status_Married','marital-status_Not-Married']]

"""# **Visualization**"""

train_data_copy.hist( figsize=(15, 10))
plt.show()

sns.jointplot(x='relationship', y='Income ', data=train_data_copy,kind='hex')

sns.jointplot(x='education-num', y='Income ', data=train_data_copy,kind='hex')

sns.jointplot(x='age', y='Income ', data=train_data_copy, kind='hex')

sns.jointplot(x='hours-per-week', y='Income ', data=train_data_copy, kind='hex')

g = sns.barplot(x="sex",y="Income ",data=train_data_copy)
g = g.set_ylabel("Income >50K Probability")
plt.show()

train_data.groupby('Income ').size().plot(kind='pie', autopct='%.2f')

train_data.groupby('relationship').size().plot(kind='pie', autopct='%.2f')

train_data.groupby('Income ').size().plot(kind='pie', autopct='%.2f')

train_data_copy.groupby('Income ').size().plot(kind='pie', autopct='%.2f')

g = sns.barplot(x="education-num",y="Income ",data=train_data_copy)
g = g.set_ylabel("Income >50K Probability")
plt.show()

sns.distplot(train_data_encoded['age'],kde="false")
# to plot column with its density
# pass kde=false as parameter if you want histogram only

"""# **KNN**

![WhatsApp Image 2023-05-20 at 7.01.59 PM.jpeg](data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/4gHYSUNDX1BST0ZJTEUAAQEAAAHIAAAAAAQwAABtbnRyUkdCIFhZWiAH4AABAAEAAAAAAABhY3NwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAA9tYAAQAAAADTLQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAlkZXNjAAAA8AAAACRyWFlaAAABFAAAABRnWFlaAAABKAAAABRiWFlaAAABPAAAABR3dHB0AAABUAAAABRyVFJDAAABZAAAAChnVFJDAAABZAAAAChiVFJDAAABZAAAAChjcHJ0AAABjAAAADxtbHVjAAAAAAAAAAEAAAAMZW5VUwAAAAgAAAAcAHMAUgBHAEJYWVogAAAAAAAAb6IAADj1AAADkFhZWiAAAAAAAABimQAAt4UAABjaWFlaIAAAAAAAACSgAAAPhAAAts9YWVogAAAAAAAA9tYAAQAAAADTLXBhcmEAAAAAAAQAAAACZmYAAPKnAAANWQAAE9AAAApbAAAAAAAAAABtbHVjAAAAAAAAAAEAAAAMZW5VUwAAACAAAAAcAEcAbwBvAGcAbABlACAASQBuAGMALgAgADIAMAAxADb/2wBDAAMCAgICAgMCAgIDAwMDBAYEBAQEBAgGBgUGCQgKCgkICQkKDA8MCgsOCwkJDRENDg8QEBEQCgwSExIQEw8QEBD/2wBDAQMDAwQDBAgEBAgQCwkLEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBD/wAARCAEsAlgDASIAAhEBAxEB/8QAHQABAAICAwEBAAAAAAAAAAAAAAcIBQYDBAkBAv/EAFcQAAEDAwMBBAQICQcGDQUBAAEAAgMEBQYHERIhCBMxQRQiUWEVGTJWcXaW0hYjNzlCgZGztAkXUmKSlKEYM0NyosE0NlNXc3WCk6Wx0dPUJEZjZeGD/8QAGwEBAAIDAQEAAAAAAAAAAAAAAAQFAgMGAQf/xAA/EQABAwMCAwUHAgQEBQUAAAABAAIRAwQhBTESQVEGEyJhcRQygZGhsfDB0RUjQlIWM1RyJYKS4fE0Q2Ki0v/aAAwDAQACEQMRAD8A9PUREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREWEvuc4Vi5IyXL7LaiPKtr4oD+x7gtGuvak0Bs7iyr1Kt8hB2/+lhnqR+2Jjh5LIMcdgolbULS2xWqtb6uA+5UqIoEru25oPSb+j3O71u223cW143/AO8LViJ+3vo1FIWR2LLpmj9NlFTgH+1OD/gs+5qHkq9/aTSGb3DfnP2VkkVaf8vvR35tZl/c6X/5C+jt96Ok7fg3mQ9/odL/APITuKnRYf4n0f8A1DVZVFX2k7cmhtQ4tmlv1KBt60tv3B/sOcVsdt7W/Z9ubmxx6gxQSO/RqaGpiA67dXOj4/4rw0njkt9PX9Lq4bcM/wCoD7qX0WqWXVnS/I3MjseoeOVsr9toorlCZOv9TlyH7FtTXNe0PY4Oa4bgg7ghYEEbqypVqVccVJwcPIyvqIi8W1EREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREXRu1+sdhg9Jvt5obdD/ylXUshb+1xAWi3ftH6F2Tf03U+xycRufQ5zV/uQ7dZBrnbBRq15bW3+dUa31IH3UkIoNru2joBSHanyaurffBa5x5f/ka36Fgqnt56LwBpitOV1G/iI6GAbfTymH+CyFGoeSrn9o9Jp73DPgQfsrHoq0/5fejvzazL+50v/wAhP8vvR35tZl/c6X/5C97ip0Wv/FGj/wCoarLIq7Unbs0SqeHfU2S0vPx76gjPD6eEjv8ADdZ+39sbs+V3ESZpNRvdsA2otlUOp9pbGWj9uy8NGoOS3U+0OlVPduGfFwH3U1ItFs+u2jV94i26nY457/kxy3COF5+hsha4/sW60tZSV0LamiqoaiF3yZInh7T9BHRYFpG4VjRuaNwJovDvQg/ZcqIi8W9EREREREREREREREREREREREREWEzbMbFp/ityzHJKkw2+2QmWUtALnncBrGgkbuc4taBuOpHUKhuR67689onLX4tgNVUWuCZsslJZrdXMpZJYmNLnB8znMdM/gCSwHY7HZnittOkameSodZ7QW+jltJwL6jvda3c/nzPIL0NReT8dm1Nh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RC9x3K3U9LsaXuUWD0aB+i6lus9os8XcWi10dDH4cKaBsTf2NAXbRFgprWhohogIiIi9RERERERERERERERERERERERERERERVd7I/5ce079foP4JitEqu9kf8uPad+v0H8ExEVokREREREREREREREREREREREREREREREREUb63Oy0WaiGO+l+imV/pvoodz8B3e/Hrx+Vv5b8d/JZPSE5KcPYcnNSZe/f6N6Tv3ncbN4779duXLbfy28tlzFPtJ3mvv0PuH+FvFx/0nAPyzEz70iOauHaRw6Y3Uu8bkxw8/znHTK3VEUTa0ZvleNXK30FkqHUVNLAZnTtjDjLJyILN3Aj1QGnYf0+vkpnaHXrfs3YO1C6a5zWkCGiTkwNyB8z9Vo0rTaurXItaJAJnfbCllFgcDvFyv8AiNtu93iDKuoiJk2bxDtnENft5cgA7p069OizysrK7p39tTu6U8L2hwnBhwkSOuVEuKDras+i/dpIMbSDCIiKStKIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiKruoP5xDSb6g3797GrRKruoP5xDSb6g3797GiK0SIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIvjnNY0vc4BrRuST0A9q+RSxTxtlglZIx3yXMcCD9BC1DVexX7IsRkoMfLnTCZkksLXhpniG+7OuwPUtdsfHj7dlh9FMWyTGrdcTfoX00dVLGYKd79y0tDg5+w6Dfdo9p4/QuYra7eU9ep6S21caTmlxq54QYJjaOQG4MkYje4p6bQfpjr41gHgxwczt5zznaMbqSURRrrhUZVT2ahdYH1UdIZX+mvpiQ8dB3YJb14/L38t+O/krDXtWGh6dV1B1MvDBPC3c5A+QmSeQBKi6bZHUbplqHBvEdzttP8A481JSLStIp8kqMPZJkzqh0vfvFO6o37x0GzdiSep9bnsT5beWy3Vb9J1AarY0r0MLO8aHQdxP58VrvbU2Vw+3Lg7hJEjYoiIrBRUREREREREREREREREVXeyP+XHtO/X6D+CYrRKrvZH/Lj2nfr9B/BMRFaJERERERERERERERERERERERERFouf6q0ODV9Pa/gqSuqZYxM8CURtYwkgddjueh6bfrW12C9UmRWakvdEHiGrjEjWvGzm+RB94II/Uqi113Tr2+q6bQqh1al7zc4+MQdxMExzU6tpt1b2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dZnGZUjqS/XuBsENG8DvKSk3DyH9ej3uDCW+LQxoOx3AKyKKG95qO4ivoumadR0q1ba0Pdb8yeZPqiIixU9ERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERf/9k=)# **KNN**
"""

acc = []
# Will take some time

for i in range(1,40):
    neigh = KNeighborsClassifier(n_neighbors = i).fit(X_train,Y_train)
    yhat = neigh.predict(X_test)
    acc.append(metrics.accuracy_score(Y_test, yhat))

plt.figure(figsize=(10,6))
plt.plot(range(1,40),acc,color = 'blue',linestyle='dashed',
         marker='o',markerfacecolor='red', markersize=10)
plt.title('accuracy vs. K Value')
plt.xlabel('K')
plt.ylabel('Accuracy')
print("Maximum accuracy:-",max(acc),"at K =",acc.index(max(acc)))

w

print("Test Confusion Matrix ")
print(confusion_matrix(Y_test,Y_pred_knn))
print(classification_report(Y_test,Y_pred_knn))

y_prob = knn.predict_proba(X_test)

precision, recall, thresholds = precision_recall_curve(Y_test, y_prob[:,1])

plt.plot(recall, precision, label='k-NN')

plt.legend()
plt.xlabel('Recall')
plt.ylabel('Precision')
plt.title('Precision-Recall Curve')
plt.show()

"""# **Gaussian Naive Bayes classifier**"""

gaussian = GaussianNB(var_smoothing=2e-9)
gaussian.fit(X_train, Y_train)
Y_pred_naive = gaussian.predict(X_test)
score_gaussian = gaussian.score(X_test,Y_test)
print('The accuracy of Gaussian Naive Bayes is', score_gaussian)

print(confusion_matrix(Y_test,Y_pred_naive))
print(classification_report(Y_test,Y_pred_naive))


y_prob = gaussian.predict_proba(X_test)

precision, recall, thresholds = precision_recall_curve(Y_test, y_prob[:,1])

plt.plot(recall, precision, label='Gaussian Naive Bayes')

plt.legend()
plt.xlabel('Recall')
plt.ylabel('Precision')
plt.title('Precision-Recall Curve')
plt.show()

"""# **SVC**"""

svm = SVC(C=50.0,kernel='rbf',degree=3, gamma='auto',random_state=42)
svm.fit(X_train, Y_train)

# Predict target values for testing set
Y_pred_svm = svm.predict(X_test)

cm = confusion_matrix(Y_test, Y_pred_svm,labels=svm.classes_)

acc = accuracy_score(Y_test, Y_pred_svm)

print(f"Accuracy: {acc}")

f1 = f1_score(Y_test,Y_pred_svm, average='weighted')

print("F1 score: {:.2f}".format(f1))

print("Confusion Matrix:")

print(cm)

y_prob_train = svm.decision_function(X_train)

precision, recall, thresholds = precision_recall_curve(Y_train, y_prob_train)

#plot precision-recall curve
plt.plot(recall, precision, marker='.')
plt.xlabel('Recall')
plt.ylabel('Precision')
plt.title('Precision-Recall Curve')
plt.show()
'''

"""# **Decision Tree algorithm**"""

decision_tree_model = DecisionTreeClassifier(max_depth=99,max_leaf_nodes=100)
decision_tree_model.fit(X_train,Y_train)
Y_pred_DecisionTree = decision_tree_model.predict(X_test)
acc_decision_tree = accuracy_score(Y_test, Y_pred_DecisionTree)
acc_decision_tree

print("Test Confusion Matrix ")

print(confusion_matrix(Y_test,Y_pred_DecisionTree))
print(classification_report(Y_test,Y_pred_DecisionTree))

y_prob = decision_tree_model.predict_proba(X_test)

precision, recall, thresholds = precision_recall_curve(Y_test, y_prob[:,1])

plt.plot(recall, precision, label='decision tree model')

plt.legend()
plt.xlabel('Recall')
plt.ylabel('Precision')
plt.title('Precision-Recall Curve')
plt.show()

"""# **Logistic Regression Model**"""

LogisticModel = LogisticRegression()
LogisticModel.fit(X_train,Y_train)

#Y_train_Logistic=LogisticModel.predict(X_train)
Y_pred_Logistic=LogisticModel.predict(X_test)

logistic_accuracy_score=accuracy_score(Y_test,Y_pred_Logistic)

logistic_accuracy_score

print("Test Confusion Matrix ")
print(confusion_matrix(Y_test,Y_pred_Logistic))
print(classification_report(Y_test,Y_pred_Logistic))

y_prob = LogisticModel.predict_proba(X_test)

precision, recall, thresholds = precision_recall_curve(Y_test, y_prob[:,1])

plt.plot(recall, precision, label='logistic model')

plt.legend()
plt.xlabel('Recall')
plt.ylabel('Precision')
plt.title('Precision-Recall Curve')
plt.show()

"""# **Random Forest Classifier**"""

Randomforest=RandomForestClassifier()
Randomforest.fit(X_train,Y_train)
Y_pred_Randomforest=Randomforest.predict(X_test)

Y_train_pred_Randomforest=Randomforest.predict(X_train)

acc_Randomforest = accuracy_score(Y_pred_Randomforest, Y_test)
print(accuracy_score(Y_test,Y_pred_Randomforest))

print(confusion_matrix(Y_test,Y_pred_Randomforest))
print(classification_report(Y_test,Y_pred_Randomforest))


y_prob = Randomforest.predict_proba(X_test)

precision, recall, thresholds = precision_recall_curve(Y_test, y_prob[:,1])

plt.plot(recall, precision, label='Random forest')

plt.legend()
plt.xlabel('Recall')
plt.ylabel('Precision')
plt.title('Precision-Recall Curve')
plt.show()

"""# **AdaBoost**"""

base_estimator = DecisionTreeClassifier(max_depth=1) # Weak learner
n_estimators = 50 # Number of weak learners
learning_rate = 1.0 # Learning rate

ada_boost = AdaBoostClassifier(base_estimator=base_estimator,
                               n_estimators=n_estimators,
                               learning_rate=learning_rate)

# Fit the AdaBoost classifier to the training data
ada_boost.fit(X_train, Y_train)

# Make predictions on the testing data
y_pred_adaboost = ada_boost.predict(X_test)

# Evaluate the performance of the AdaBoost classifier
accuracy = accuracy_score(Y_test, y_pred_adaboost)

# Print the accuracy of the AdaBoost classifier
print("Accuracy:", accuracy)

print(confusion_matrix(Y_test,y_pred_adaboost))
print(classification_report(Y_test,y_pred_adaboost))


y_prob = ada_boost.predict_proba(X_test)

precision, recall, thresholds = precision_recall_curve(Y_test, y_prob[:,1])

plt.plot(recall, precision, label='Random forest')

plt.legend()
plt.xlabel('Recall')
plt.ylabel('Precision')
plt.title('Precision-Recall Curve')
plt.show()

"""# **XGBoost**"""

import xgboost as xgb
import numpy as np
from sklearn.metrics import accuracy_score

# Load your dataset and split it into training and testing sets

# Define the number of classes in the target variable
num_classes = len(np.unique(Y_train))

# Define the hyperparameters for the XGBoost classifier
params = {
    'max_depth': 3, # Maximum depth of each decision tree
    'eta': 0.1, # Learning rate
    'objective': 'multi:softmax', # Multi-class classification
    'num_class': num_classes # Number of classes in the target variable

}

# Create a DMatrix for the training and testing data
d_train = xgb.DMatrix(X_train, label=Y_train)
d_test = xgb.DMatrix(X_test, label=Y_test)

# Train the XGBoost classifier
num_rounds = 50 # Number of boosting rounds
xgboost_classifier= xgb.train(params, d_train, num_rounds)

# Make predictions on the testing data
Y_pred_XGB = xgboost_classifier.predict(d_test)

# Evaluate the performance of the XGBoost classifier
accuracy = accuracy_score(Y_test, Y_pred_XGB)

# Print the accuracy of the XGBoost classifier
print("Accuracy:", accuracy)

print(confusion_matrix(Y_test,Y_pred_XGB))
print(classification_report(Y_test,Y_pred_XGB))

"""# **Feature Selection using Chi-Square**"""

Xtrain_data_copy=train_data_copy.drop(['Income '],axis=1)

Ytrain_data_copy=train_data_copy['Income ']

Xtset_data_copy=test_data_copy.drop(['Income '],axis=1)

k = 5  # Number of top features to select
selector = SelectKBest(score_func=chi2, k=k)
X_train_selected = selector.fit_transform(Xtrain_data_copy, Ytrain_data_copy)

# Get the feature scores
feature_scores = selector.scores_

# Create a list of (score, feature_name) tuples
feature_scores_list = [(score, feature_name) for score, feature_name in zip(feature_scores, Xtrain_data_copy.columns)]

# Sort the feature scores list in descending order
feature_scores_list.sort(reverse=True)

# Get the top k features with highest scores
top_features = [feature_name for _, feature_name in feature_scores_list[:k]]

# Print the top features
print("Top", k, "features with highest scores:")
for feature in top_features:
    print(feature)

"""# **Information Gain Feature Selection**"""

train_data_copy.head()

# Commented out IPython magic to ensure Python compatibility.
#mutual_info_classif
# %matplotlib inline

train_data_copy_x=train_data_copy.drop(['Income '],axis=1)
train_data_copy_y=train_data_copy['Income ']

impotrances = mutual_info_classif(train_data_copy_x,train_data_copy_y)
feature_importances = pd.Series(impotrances,train_data_copy_x.columns[0:len(train_data_copy_x)-1])
feature_importances.plot(kind='barh',color='teal')
plt.show()

for i in train_data_encoded.columns:
  print(i)

X_train_IG=train_data_encoded[['age','education-num','capital-gain','relationship_ Husband','relationship_ Not-in-family','relationship_ Other-relative','relationship_ Own-child','relationship_ Unmarried','relationship_ Wife','marital-status_Married','marital-status_Not-Married']]

X_test_IG=test_data_encoded[['age','education-num','capital-gain','relationship_ Husband','relationship_ Not-in-family','relationship_ Other-relative','relationship_ Own-child','relationship_ Unmarried','relationship_ Wife','marital-status_Married','marital-status_Not-Married']]

"""# **Models with information gain**"""

#logistiic
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import classification_report,confusion_matrix
from sklearn.metrics import accuracy_score

LogisticModel = LogisticRegression()
LogisticModel.fit(X_train_IG,Y_train)

#Y_train_Logistic=LogisticModel.predict(X_train)
Y_pred_Logistic=LogisticModel.predict(X_test_IG)

logistic_accuracy_score=accuracy_score(Y_test,Y_pred_Logistic)

logistic_accuracy_score

#Decision tree
decision_tree_model = DecisionTreeClassifier(max_depth=99,max_leaf_nodes=100)
decision_tree_model.fit(X_train_IG,Y_train)
Y_pred_DecisionTree = decision_tree_model.predict(X_test_IG)
acc_decision_tree = accuracy_score(Y_test, Y_pred_DecisionTree)
acc_decision_tree

#KNN
knn=KNeighborsClassifier(n_neighbors=3)
knn.fit(X_train_IG,Y_train)
Y_pred_knn=knn.predict(X_test_IG)
#Y_train_pred_knn=knn.predict(X_test_IG)
acc_knn = accuracy_score(Y_pred_knn, Y_test)
print(acc_knn)

#SVM
svm = SVC(C=50.0,kernel='rbf',degree=3, gamma='auto',random_state=42)
svm.fit(X_train_IG, Y_train)

# Predict target values for testing set
Y_pred_svm = svm.predict(X_test_IG)
cm = confusion_matrix(Y_test, Y_pred_svm,labels=svm.classes_)

acc = accuracy_score(Y_test, Y_pred_svm)

print(f"Accuracy: {acc}")

#Naive Bayes
from sklearn.naive_bayes import GaussianNB

gaussian = GaussianNB()
gaussian.fit(X_train_IG, Y_train)
Y_pred_naive = gaussian.predict(X_test_IG)
score_gaussian = gaussian.score(X_test_IG,Y_test)
print('The accuracy of Gaussian Naive Bayes is', score_gaussian)

#adaboost
base_estimator = DecisionTreeClassifier(max_depth=1) # Weak learner
n_estimators = 50 # Number of weak learners
learning_rate = 1.0 # Learning rate

ada_boost = AdaBoostClassifier(base_estimator=base_estimator,
                               n_estimators=n_estimators,
                               learning_rate=learning_rate)

# Fit the AdaBoost classifier to the training data
ada_boost.fit(X_train_IG, Y_train)

# Make predictions on the testing data
y_pred_adaboost = ada_boost.predict(X_test_IG)

# Evaluate the performance of the AdaBoost classifier
accuracy = accuracy_score(Y_test, y_pred_adaboost)

# Print the accuracy of the AdaBoost classifier
print("Accuracy:", accuracy)

#xgboost
import xgboost as xgb
import numpy as np
from sklearn.metrics import accuracy_score

# Load your dataset and split it into training and testing sets

# Define the number of classes in the target variable
num_classes = len(np.unique(Y_train))

# Define the hyperparameters for the XGBoost classifier
params = {
    'max_depth': 3, # Maximum depth of each decision tree
    'eta': 0.1, # Learning rate
    'objective': 'multi:softmax', # Multi-class classification
    'num_class': num_classes # Number of classes in the target variable

}

# Create a DMatrix for the training and testing data
d_train = xgb.DMatrix(X_train_IG, label=Y_train)
d_test = xgb.DMatrix(X_test_IG, label=Y_test)

# Train the XGBoost classifier
num_rounds = 50 # Number of boosting rounds
xgboost_classifier= xgb.train(params, d_train, num_rounds)

# Make predictions on the testing data
Y_pred_XGB = xgboost_classifier.predict(d_test)

# Evaluate the performance of the XGBoost classifier
accuracy = accuracy_score(Y_test, Y_pred_XGB)

# Print the accuracy of the XGBoost classifier
print("Accuracy:", accuracy)

#decision tree
decision_tree_model = DecisionTreeClassifier(max_depth=99,max_leaf_nodes=100)
decision_tree_model.fit(X_train_IG,Y_train)
Y_pred_DecisionTree = decision_tree_model.predict(X_test_IG)
acc_decision_tree = accuracy_score(Y_test, Y_pred_DecisionTree)
acc_decision_tree

#Random forest
Randomforest=RandomForestClassifier()
Randomforest.fit(X_train_IG,Y_train)
Y_pred_Randomforest=Randomforest.predict(X_test_IG)

Y_train_pred_Randomforest=Randomforest.predict(X_train_IG)

acc_Randomforest = accuracy_score(Y_pred_Randomforest, Y_test)
print(accuracy_score(Y_test,Y_pred_Randomforest))

"""# **models after chi**"""

X_train_chi=train_data_encoded[['capital-gain','capital-loss','fnlwgt','age','hours-per-week']]
X_test_chi=test_data_encoded[['capital-gain','capital-loss','fnlwgt','age','hours-per-week']]
d_test_chi=test_data_encoded[['capital-gain','capital-loss','fnlwgt','age','hours-per-week']]

#adaboost
base_estimator = DecisionTreeClassifier(max_depth=1) # Weak learner
n_estimators = 50 # Number of weak learners
learning_rate = 1.0 # Learning rate

ada_boost = AdaBoostClassifier(base_estimator=base_estimator,
                               n_estimators=n_estimators,
                               learning_rate=learning_rate)

# Fit the AdaBoost classifier to the training data
ada_boost.fit(X_train_chi, Y_train)

# Make predictions on the testing data
y_pred_adaboost = ada_boost.predict(X_test_chi)

# Evaluate the performance of the AdaBoost classifier
accuracy = accuracy_score(Y_test, y_pred_adaboost)

# Print the accuracy of the AdaBoost classifier
print("Accuracy:", accuracy)

#xgboost
import xgboost as xgb
import numpy as np
from sklearn.metrics import accuracy_score

# Load your dataset and split it into training and testing sets

# Define the number of classes in the target variable
num_classes = len(np.unique(Y_train))

# Define the hyperparameters for the XGBoost classifier
params = {
    'max_depth': 3, # Maximum depth of each decision tree
    'eta': 0.1, # Learning rate
    'objective': 'multi:softmax', # Multi-class classification
    'num_class': num_classes # Number of classes in the target variable

}

# Create a DMatrix for the training and testing data
d_train = xgb.DMatrix(X_train_chi, label=Y_train)
d_test = xgb.DMatrix(X_test_chi, label=Y_test)

# Train the XGBoost classifier
num_rounds = 50 # Number of boosting rounds
xgboost_classifier= xgb.train(params, d_train, num_rounds)

# Make predictions on the testing data
Y_pred_XGB = xgboost_classifier.predict(d_test)

# Evaluate the performance of the XGBoost classifier
accuracy = accuracy_score(Y_test, Y_pred_XGB)

# Print the accuracy of the XGBoost classifier
print("Accuracy:", accuracy)

#SVM
svm = SVC(C=50.0,kernel='rbf',degree=3, gamma='auto',random_state=42)
svm.fit(X_train_chi, Y_train)

# Predict target values for testing set
Y_pred_svm = svm.predict(X_test_chi)
cm = confusion_matrix(Y_test, Y_pred_svm,labels=svm.classes_)

acc = accuracy_score(Y_test, Y_pred_svm)

print(f"Accuracy: {acc}")

#logistic
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import classification_report,confusion_matrix
from sklearn.metrics import accuracy_score

LogisticModel = LogisticRegression()
LogisticModel.fit(X_train_chi,Y_train)

#Y_train_Logistic=LogisticModel.predict(X_train)
Y_pred_Logistic=LogisticModel.predict(X_test_chi)

logistic_accuracy_score=accuracy_score(Y_test,Y_pred_Logistic)

logistic_accuracy_score

#decision tree
decision_tree_model = DecisionTreeClassifier(max_depth=99,max_leaf_nodes=100)
decision_tree_model.fit(X_train_chi,Y_train)
Y_pred_DecisionTree = decision_tree_model.predict(X_test_chi)
acc_decision_tree = accuracy_score(Y_test, Y_pred_DecisionTree)
acc_decision_tree

#KNN

knn=KNeighborsClassifier(n_neighbors=23)
knn.fit(X_train_chi,Y_train)
Y_pred_knn=knn.predict(X_test_chi)
#Y_train_pred_knn=knn.predict(X_test_IG)
acc_knn = accuracy_score(Y_pred_knn, Y_test)
print(acc_knn)

#Naive bayes
from sklearn.naive_bayes import GaussianNB

gaussian = GaussianNB()
gaussian.fit(X_train_chi, Y_train)
Y_pred_naive = gaussian.predict(X_test_chi)
score_gaussian = gaussian.score(X_test_chi,Y_test)
print('The accuracy of Gaussian Naive Bayes is', score_gaussian)

#Random forest
Randomforest=RandomForestClassifier()
Randomforest.fit(X_train_chi,Y_train)
Y_pred_Randomforest=Randomforest.predict(X_test_chi)

Y_train_pred_Randomforest=Randomforest.predict(X_test_chi)

acc_Randomforest = accuracy_score(Y_pred_Randomforest, Y_test)
print(accuracy_score(Y_test,Y_pred_Randomforest))